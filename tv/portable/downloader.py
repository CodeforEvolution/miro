from database import DDBObject, defaultDatabase
from threading import Thread, Event, RLock
from httplib import HTTPConnection, HTTPSConnection,HTTPException
from scheduler import ScheduleEvent
import config
import traceback
import socket
from base64 import b64encode

from time import sleep,time
from urlparse import urlparse,urljoin
from os import remove, rename, access, F_OK
import re
import math
from copy import copy

from BitTorrent import configfile
from BitTorrent.download import Feedback, Multitorrent
from BitTorrent.defaultargs import get_defaults
from BitTorrent.parseargs import parseargs, printHelp
from BitTorrent.bencode import bdecode
from BitTorrent.ConvertedMetainfo import ConvertedMetainfo
from BitTorrent import configfile
from BitTorrent import BTFailure, CRITICAL
from BitTorrent import version

import sys
import os
import threading
from time import time, strftime
from signal import signal, SIGWINCH
from cStringIO import StringIO

defaults = get_defaults('btdownloadheadless')
defaults.extend((('donated', '', ''),
                 ))

# Pass in a connection to the frontend
def setDelegate(newDelegate):
    global delegate
    delegate = newDelegate

#FIXME: check for free space and failed connection to tracker and fail
#on those cases

class DownloaderError(Exception):
    pass

# Returns an HTTP auth object corresponding to the given host, path or
# None if it doesn't exist
def findHTTPAuth(host,path,realm = None,scheme = None):
    #print "Trying to find HTTPAuth with host %s, path %s, realm %s, and scheme %s" %(host,path,realm,scheme)
    ret = None
    defaultDatabase.beginRead()
    try:
        for obj in defaultDatabase:
            if (isinstance(obj,HTTPAuthPassword) and
                obj.host == host and path.startswith(obj.path) and
                (realm is None or obj.realm == realm) and
                (scheme is None or obj.authScheme == scheme)):
                ret = obj
                break
    finally:
        defaultDatabase.endRead()
    return ret
        

# FIXME: Currently, returns a None object in the case where it can't
# download the file. In the future, we should probably raise
# exceptions for each possible failure case and catch those everywhere
# this is used.

# Given a URL returns an info object which may contain the following
# keys: content-length, accept-ranges, server, last-modified, date,
# etag, content-type, redirected-url, updated-url, file-handle
#
# redirected-url, updated-url, filename, and file-handle are generated by
# getURLInfo. All of the other information is grabbed from the actual
# HTTP headers.
#
# Currently, only GET and HEAD requests are supported
#
# File handle is passed when a GET request is made. Call read() on it
# until read() returns '', then call close(). If you do not call
# close(), the connection will never be freed up.
#
# Redirected URL is the URL actually loaded after all of the redirects.
# Updated-url is the URL of the last permanent redirect
def grabURL(url, type="GET",start = 0, etag=None,modified=None):
    maxDepth = 10
    maxAuthAttempts = 5
    redirURL = url
    myHeaders = {"User-Agent":"DTV/pre-release (http://participatoryculture.org/)"}

    (scheme, host, path, params, query, fragment) = urlparse(url)
    #print "grab URL called for "+host

    auth = findHTTPAuth(host,path)
    if not auth is None:
        #print " adding auth header"
        myHeaders["Authorization"] = auth.getAuthScheme()+' '+auth.getAuthToken()

    if len(params):
        path += ';'+params
    if len(query):
        path += '?'+query

    if start > 0:
        myHeaders["Range"] = "bytes="+str(start)+"-"

    if not etag is None:
        myHeaders["If-None-Match"] = etag

    if not modified is None:
        myHeaders["If-Modified-Since"] = modified

    download = connectionPool.getRequest(scheme,host,type,path, headers = myHeaders)

    if download is None:
        return None

    #print "Got it!"
    depth = 0
    authAttempts = 0
    while ((download.status != 304) and
           ((start == 0 and download.status != 200) or
            (start > 0 and download.status != 206)) and 
           (depth < maxDepth and authAttempts < maxAuthAttempts)):
        if download.status == 302 or download.status == 307 or download.status == 301:
            #print " redirect"
            depth += 1
            info = download.msg
            download.close()
            redirURL = urljoin(redirURL,info['location'])
            if download.status == 301:
                url = redirURL
            (scheme, host, path, params, query, fragment) = urlparse(redirURL)

            try:
                del myHeaders["Authorization"]
            except KeyError:
                pass
            auth = findHTTPAuth(host,path)
            if not auth is None:
                #print " adding auth header"
                myHeaders["Authorization"] = auth.getAuthScheme()+' '+auth.getAuthToken()

            if len(params):
                path += ';'+params
            if len(query):
                path += '?'+query
            #print "getURLInfo Redirected to "+host
            download = connectionPool.getRequest(scheme,host,type,path, headers=myHeaders)
            if download is None:
                return None
        elif download.status == 401:
            if download.msg.has_key('WWW-Authenticate'):
                authAttempts += 1
                info = download.msg
                download.close()
                regExp = re.compile("^(.*?)\s+realm\s*=\s*\"(.*?)\"$").search(info['WWW-Authenticate'])
                authScheme = regExp.expand("\\1")
                realm = regExp.expand("\\2")
                #print "Trying to authenticate "+host+" realm:"+realm
                result = delegate.getHTTPAuth(host,realm)
                if not result is None:
                    auth = HTTPAuthPassword(result[0],result[1],host, realm, path, authScheme)
                    myHeaders["Authorization"] = auth.getAuthScheme()+' '+auth.getAuthToken()
                    download = connectionPool.getRequest(scheme,host,type,path, headers=myHeaders)
                #This is where we would do our magic to prompt for a password
                #If we get a good password, we save it
            else:
                break
        else: #Some state we don't handle
            break

    # Valid or cached pages
    if not download.status in [200,206,304]:
        return None

    #print "processing request"
    info = download.msg
    myInfo = {}
    for key in info.keys():
        myInfo[key] = info[key]
    info = myInfo
    if type == 'GET':
        info['file-handle'] = download
    else:
        download.close()
    #print "closed request"

    try:
        disposition = info['content-disposition']
        info['filename'] = re.compile("^.*filename\s*=\s*\"(.*?)\"$").search(disposition).expand("\\1")
        info['filename'].replace ("/","")
        info['filename'].replace ("\\","")
    except KeyError:
        try:
            info['filename'] = re.compile("^.*?([^/]+)/?$").search(path).expand("\\1")
        except AttributeError:
            info['filename'] = 'unknown'

    info['redirected-url'] = redirURL
    info['updated-url'] = url
    info['status'] = download.status
    return info

class HTTPAuthPassword(DDBObject):
    def __init__(self,username,password,host, realm, path, authScheme="Basic"):
        oldAuth = findHTTPAuth(host,path,realm,authScheme)
        while not oldAuth is None:
            oldAuth.remove()
            oldAuth = findHTTPAuth(host,path,realm,authScheme)
        self.username = username
        self.password = password
        self.host = host
        self.realm = realm
        self.path = os.path.dirname(path)
        self.authScheme = authScheme
        DDBObject.__init__(self)

    def getAuthToken(self):
        authString = ':'
        self.beginRead()
        try:
            authString = self.username+':'+self.password
        finally:
            self.endRead()
        return b64encode(authString)

    def getAuthScheme(self):
        ret = ""
        self.beginRead()
        try:
            ret = self.authScheme
        finally:
            self.endRead()
        return ret

# An HTTP response that tells the connection pool when it is free,
# so that the connection can be reused
class PooledHTTPResponse:
    def __init__(self,conn,response,connPool):
        self.conn = conn
        self.response = response
        self.connPool = connPool
        self.beenRead = False

    def read(self,amt=None):
        if amt is None:
            ret = ''
            next = self.response.read()
            while len(next) > 0:
                ret += next
                next = self.response.read()
            self.beenRead = True
        else:
            ret = self.response.read(amt)
        if ret == '':
            self.beenRead = True
        return ret

    def getheader(self,name,default = None):
        if isinstance(default, None):
            return self.response.getheader(name)
        else:
            return self.response.getheader(name,default)
        
    def getheaders(self):
        return self.response.getheaders()

    def __getattr__(self,key):
        return getattr(self.response, key)

    #
    # Use like close(), but in the middle of a download
    def kill(self):
        if not self.beenRead:
            self.connPool.removeConn(self.conn)
        else:
            self.connPool.freeConn(self.conn)

    def close(self):
        if not self.beenRead:
            #print "Closing unread response..."+str(self.response)
            try:
                out = self.response.read(8192)
                while len(out)>0:
                     #print "still closing "+str(self.response)
                    out = self.response.read(8192)
                #print "done closing"
                self.connPool.freeConn(self.conn)
            except ValueError:
                print "Caught error in httplib"
                self.connPool.removeConn(self.conn)

    ##
    # Called by pickle during serialization
    def __getstate__(self):
        assert(0) #This should never be serialized

#
# This class a set of HTTP connections so that we always do the
# optimal thing when we need a new connection. Generally, if there's a
# free existing connection, we use that, otherwise we create a new one
#
# FIXME: add certificate validation for HTTPS
class HTTPConnectionPool:

    # The maximum number of connections we keep active. The total
    # number may exceed this, but free connections that bring the
    # total number above maxConns will be closed
    maxConns = 30
    maxConnsPerServer = 8
    connTimeout = 300
    def __init__(self):
        self.conns={'free':{'http':{},'https':{}},
                    'inuse':{'http':{},'https':{}}}
        self.lock = RLock()

    def __len__(self):
        self.lock.acquire()
        try:
            length = 0
            for state in self.conns:
                for protocol in self.conns[state]:
                    for host in self.conns[state][protocol]:
                        length += len(self.conns[state][protocol][host])
        finally:
            self.lock.release()
        return length

    # moves connection from inuse to free
    #
    # get your freeConn!
    def freeConn(self,conn):
        freed = False
        #print "Trying to free connection..."
        self.lock.acquire()
        try:
            for prot in self.conns['inuse']:
                for h in self.conns['inuse'][prot]:
                    try:
                        index = self.conns['inuse'][prot][h].index(conn)
                        del self.conns['inuse'][prot][h][index]
                        protocol = prot
                        host = h
                        freed = True
                    except ValueError:
                        pass
            if freed:
                #print "Connection to "+host+ " is idle"
                if not self.conns['free'][protocol].has_key(host):
                    self.conns['free'][protocol][host] = []
                self.conns['free'][protocol][host].append((conn, time()+self.connTimeout))
            #else:
                #print "Not freed!"
        finally:
            self.lock.release()

    #
    # Removes a connection from the pool
    def removeConn(self,conn):
        self.lock.acquire()
        try:
            for protocol in self.conns['free']:
                for host in self.conns['free'][protocol]:
                    for pair in self.conns['free'][protocol][host]:
                        if pair[0] is conn:
                            #print "Removing connection to "+host
                            self.conns['free'][protocol][host].remove(pair)
            for protocol in self.conns['inuse']:
                for host in self.conns['inuse'][protocol]:
                    for uConn in self.conns['inuse'][protocol][host]:
                        if uConn is conn:
                            #print "Removing connection to "+host
                            self.conns['inuse'][protocol][host].remove(uConn)
        finally:
            self.lock.release()
        conn.close()

    def removeOldestFreeConnection(self):
        #print "Removing oldest connection..."
        self.lock.acquire()
        try:
            conn = None
            oldest = -1
            for protocol in self.conns['free']:
                for host in self.conns['free'][protocol]:
                    for (newConn, newExp) in self.conns['free'][protocol][host]:
                        if newExp > oldest:
                            oldest = newExp
                            conn = newConn
            if not (conn is None):
                self.removeConn(conn)
        finally:
            self.lock.release()
        #print "...done"

    def removeOldestFreeByHost(self,protocol,host):
        #print "Removing oldest connection to "+host+"..."
        self.lock.acquire()
        try:
            conn = None
            oldest = -1
            for (newConn, newExp) in self.conns['free'][protocol][host]:
                if newExp > oldest:
                    oldest = newExp
                    conn = newConn
            if not (conn is None):
                self.removeConn(conn)
        finally:
            self.lock.release()
        #print "...done"

    def expireOldConnections(self):
        now = time()
        self.lock.acquire()
        try:
            for protocol in self.conns['free']:
                for host in self.conns['free'][protocol]:
                    for pair in self.conns['free'][protocol][host]:
                        if pair[1] <= now:
                            #print "Expiring connection to "+host
                            pair[0].close()
                            self.conns['free'][protocol][host].remove(pair)
        finally:
            self.lock.release()

    def getNumConnsByHost(self,protocol,host):
        self.lock.acquire()
        try:
            if not self.conns['free'][protocol].has_key(host):
                self.conns['free'][protocol][host] = []
            if not self.conns['inuse'][protocol].has_key(host):
                self.conns['inuse'][protocol][host] = []
            ret = (len(self.conns['inuse'][protocol][host])+
                   len(self.conns['free'][protocol][host]))
        finally:
            self.lock.release()
        return ret

    def getRequest(self,protocol,host,method,url,*args,**keywords):
        #print "Making "+protocol+" connection to "+host+"..."
        madeNewConn = False
        self.lock.acquire()
        try:
            conn = None
            self.expireOldConnections()
            if (self.conns['free'][protocol].has_key(host) and
                        len(self.conns['free'][protocol][host]) > 0):
                (conn, expiration) = self.conns['free'][protocol][host].pop(0)
                if not self.conns['inuse'][protocol].has_key(host):
                    self.conns['inuse'][protocol][host] = []
                self.conns['inuse'][protocol][host].append(conn)
                #print "Using existing connection"
        finally:
            self.lock.release()
        
        # We don't already have a connection -- get one
        if conn is None:
            madeNewConn = True
            #print "Making new connection..."
            if protocol.lower() == 'http':
                conn = HTTPConnection(host)
            elif protocol.lower() == 'https':
                conn = HTTPSConnection(host)

            #Save our newly created connection
            self.lock.acquire()
            try:   
                if not self.conns['free'][protocol].has_key(host):
                    self.conns['free'][protocol][host] = []
                if not self.conns['inuse'][protocol].has_key(host):
                    self.conns['inuse'][protocol][host] = []
            
                if (self.getNumConnsByHost(protocol,host) == 
                                                 self.maxConnsPerServer):
                    self.removeOldestFreeByHost(protocol, host)

                if len(self) == self.maxConns:
                    self.removeOldestFreeConnection()
                if (len(self) < self.maxConns and 
                self.getNumConnsByHost(protocol,host) < self.maxConnsPerServer):
                    if not self.conns['inuse'][protocol].has_key(host):
                        self.conns['inuse'][protocol][host] = []
                    self.conns['inuse'][protocol][host].append(conn)
                    #print "...saving connection"
                #else:
                    #print "...not saving connection"
            finally:
                self.lock.release()

        #print "Making request..."
        try:
            conn.request(method,url,*args,**keywords)
        except socket.error:
            if madeNewConn:
                return None
            else: # We had a connection before. Maybe the connection
                  # just timed out...
                #print "An old connection may have timed out. Trying again."
                self.removeConn(conn)
                return self.getRequest(protocol,host,method,url,*args,**keywords)

        #print "Getting response..."
        try:
            response = conn.getresponse()
        except (HTTPException, socket.timeout):
            if madeNewConn:
                return None
            else: # We had a connection before. Maybe the connection
                  # just timed out...
                #print "An old connection may have timed out. Trying again."
                self.removeConn(conn)
                return self.getRequest(protocol,host,method,url,*args,**keywords)
        #print "Leaving connectionPool"
        return PooledHTTPResponse(conn,response,self)

    ##
    # Called by pickle during serialization
    def __getstate__(self):
        assert(0) #This should never be serialized

connectionPool = HTTPConnectionPool()

class Downloader(DDBObject):
    def __init__(self, url,item):
        self.url = url
	self.item = item
        self.startTime = time()
        self.endTime = self.startTime
	self.shortFilename = self.filenameFromURL(url)
        self.filename = os.path.join(config.get('DataDirectory'),'Incomplete Downloads',self.shortFilename+".part")
	self.filename = self.nextFreeFilename(self.filename)
        self.state = "downloading"
        self.currentSize = 0
        self.totalSize = -1
        self.blockTimes = []
        self.headers = None
        DDBObject.__init__(self)
        self.thread = Thread(target=self.runDownloader)
        self.thread.setDaemon(True)
        self.thread.start()

    ##
    # Finds a filename that's unused and similar the the file we want
    # to download
    def nextFreeFilename(self, name):
	if not access(name,F_OK):
	    return name
	parts = name.split('.')
	insertPoint = len(parts)-1
	count = 1
	parts[insertPoint:insertPoint] = [str(count)]
	newname = '.'.join(parts)
	while access(newname,F_OK):
	    count += 1
	    parts[insertPoint] = str(count)
	    newname = '.'.join(parts)
	return newname


    ##
    # Returns the URL we're downloading
    def getURL(self):
        self.beginRead()
        ret = self.url
        self.endRead()
        return ret
    ##    
    # Returns the state of the download: downloading, paused, stopped,
    # failed, or finished
    def getState(self):
        self.beginRead()
        ret = self.state
        self.endRead()
        return ret

    ##
    # Returns the total size of the download in bytes
    def getTotalSize(self):
        self.beginRead()
        ret = self.totalSize
        self.endRead()
        return ret

    ##
    # Returns the current amount downloaded in bytes
    def getCurrentSize(self):
        self.beginRead()
        ret = self.currentSize
        self.endRead()
        return ret

    ##
    # Returns a float with the estimated number of seconds left
    def getETA(self):
        self.beginRead()
        try:
            rate = self.getRate()
            if rate != 0:
                eta = (self.totalSize - self.currentSize)/rate
                if eta < 0:
                    eta = 0
            else:
                eta = 0
        finally:
            self.endRead()
        return eta

    ##
    # Returns a float with the download rate in bytes per second
    def getRate(self):
        now = time()
        self.beginRead()
        try:
            if self.endTime != self.startTime:
                rate = self.currentSize/(self.endTime-self.startTime)
            else:
                try:
                    if (now-self.blockTimes[0][0]) != 0:
                        rate=(self.blockTimes[-1][1]-self.blockTimes[0][1])/(now-self.blockTimes[0][0])
                    else:
                        rate = 0
                except IndexError:
                    rate = 0
        finally:
            self.endRead()
        return rate

    ##
    # Returns the filename that we're downloading to. Should not be
    # called until state is "finished."
    def getFilename(self):
        self.beginRead()
        ret = self.filename
        self.endRead()
        return ret

    ##
    # Returns a reasonable filename for saving the given url
    def filenameFromURL(self,url):
        (scheme, host, path, params, query, fragment) = urlparse(url)
        if len(path):
            try:
                return re.compile("^.*?([^/]+)/?$").search(path).expand("\\1")
            except:
                return 'unknown'
        else:
            return "unknown"

    def runDownloader(self):
        pass

    ##
    # Called by pickle during serialization
    def __getstate__(self):
	temp = copy(self.__dict__)
	temp["thread"] = None
	return temp

    ##
    # Called by pickle during deserialization
    def __setstate__(self,state):
	self.__dict__ = state
        self.thread = Thread(target=lambda :self.runDownloader(retry = True))
        self.thread.setDaemon(True)
        self.thread.start()


class HTTPDownloader(Downloader):
    def __init__(self, url,item):
	self.lastUpdated = 0
	self.lastSize = 0
	Downloader.__init__(self,url,item)

    ##
    # Update the download rate and eta based on recieving length bytes
    def updateRateAndETA(self,length):
        now = time()
	updated = False
        self.beginRead()
        try:
            self.currentSize = self.currentSize + length
	    if self.lastUpdated < now-3:
		self.blockTimes.append((now,  self.currentSize))
	        #Only keep the last 100 packets
		if len(self.blockTimes)>100:
		    self.blockTimes.pop(0)
	        updated = True
		self.lastUpdated = now
        finally:
            self.endRead()
	if updated:
	    self.item.beginChange()
	    self.item.endChange()

    ##
    # Grabs the next block from the HTTP connection
    def getNextBlock(self,handle):
        self.beginRead()
        state = self.state
        self.endRead()
        if (state == "paused") or (state == "stopped"):
            data = ""
	else:
	    try:
		data = handle.read(1024)
	    except:
		self.beginRead()
		self.state = "failed"
		self.endRead()
		data = ""
        self.updateRateAndETA(len(data))
        return data

    ##
    # This is the actual download thread.
    def runDownloader(self, retry = False):
        if retry:
            self.beginRead()
            pos = self.currentSize
            self.endRead()
            try:
                filehandle = file(self.filename,"r+b")
                filehandle.seek(pos)
            except:
                filehandle = file(self.filename,"w+b")
                self.beginRead()
                self.currentSize = 0
                totalSize = self.totalSize
                self.endRead()
                pos = 0
		if totalSize > 0:
		    filehandle.seek(totalSize-1)
		    filehandle.write(' ')
		    filehandle.seek(0)

            info = grabURL(self.url,"GET",pos)
            if info is None and pos > 0:
                pos = 0
                self.beginRead()
                self.currentSize = 0
                self.endRead()
                info = grabURL(self.url,"GET")       
            if info is None:
                self.beginRead()
                try:
                    self.state = "failed"
                finally:
                    self.endRead()
                return False
        else:
            #print "We don't have any INFO..."
            info = grabURL(self.url,"GET")
            if info is None:
                self.beginRead()
                try:
                    self.state = "failed"
                finally:
                    self.endRead()
                return False

        if not retry:
            #get the filename to save to
            self.beginRead()
            try:
                self.shortFilename = info['filename']
                self.filename = os.path.join(config.get('DataDirectory'),'Incomplete Downloads',self.shortFilename+".part")
                self.filename = self.nextFreeFilename(self.filename)
            finally:
                self.endRead()

            #Get the length of the file, then create it
            self.beginRead()
            try:
                try:
                    totalSize = int(info['content-length'])
                except KeyError:
                    totalSize = -1
                self.totalSize = totalSize
            finally:
                self.endRead()
            filehandle = file(self.filename,"w+b")
            self.beginRead()
            self.currentSize = 0
            self.endRead()
            pos = 0
            if totalSize > 0:
                filehandle.seek(totalSize-1)
                filehandle.write(' ')
                filehandle.seek(0)

        #Download the file
        if pos != self.totalSize:
            data = self.getNextBlock(info['file-handle'])
            while len(data) > 0:
                filehandle.write(data)
                data = self.getNextBlock(info['file-handle'])
            filehandle.close()
            info['file-handle'].kill()

        #Update the status
        self.beginRead()
        try:
            if self.state == "downloading":
                self.state = "finished"
		self.item.setDownloadedTime()
		newfilename = os.path.join(config.get('DataDirectory'),self.shortFilename)
		newfilename = self.nextFreeFilename(newfilename)
		rename(self.filename,newfilename)
		self.filename = newfilename
                if self.totalSize == -1:
                    self.totalSize = self.currentSize
                self.endTime = time()
        finally:
            self.endRead()
            defaultDatabase.recomputeFilters()
 

    ##
    # Pauses the download. Currently there's a flaw in the
    # implementation where this will block until the next packet is
    # received
    def pause(self):
        self.beginRead()
        self.state = "paused"
        self.endRead()
	self.item.beginChange()
	self.item.endChange()
        self.thread.join()

    ##
    # Stops the download and removes the partially downloaded
    # file. Currently there's a flaw in the implementation where this
    # will block until the next packet is received
    def stop(self):
        self.beginRead()
        self.state = "stopped"
        self.endRead()
	self.item.beginChange()
	self.item.endChange()
        self.thread.join()
        try:
            remove(self.filename)
        except:
            pass

    ##
    # Continues a paused or stopped download thread
    def start(self):
        self.pause() #Pause the download thread
        self.beginRead()
        self.state = "downloading"
        self.endRead()
	self.item.beginChange()
	self.item.endChange()
	self.runDownloader(True)

    ##
    # Removes downloader from the database
    def remove(self):
        self.pause()
        DDBObject.remove(self)

##
# BitTorrent uses this class to display status information. We use
# it to update Downloader information
#
# We use the rate and ETA provided by BitTorrent rather than
# calculating our own.
class BTDisplay:
    ##
    # Takes in the downloader class associated with this display
    def __init__(self,dler):
        self.dler = dler
	self.lastUpTotal = 0
	self.lastUpdated = 0

    def finished(self):
	self.dler.item.setDownloadedTime()
        self.dler.beginRead()
	try:
	    if not self.dler.state == "finished":
		self.dler.state = "finished"
		newfilename = os.path.join(config.get('DataDirectory'),self.dler.shortFilename)
		newfilename = self.dler.nextFreeFilename(newfilename)
		rename(self.dler.filename,newfilename)
		self.dler.filename = newfilename
		self.dler.endTime = time()
		if self.dler.endTime - self.dler.startTime != 0:
		    self.dler.rate = self.dler.totalSize/(self.dler.endTime-self.dler.startTime)
		self.dler.currentSize =self.dler.totalSize
		self.dler.multitorrent.singleport_listener.remove_torrent(self.dler.metainfo.infohash)
		self.dler.torrent = self.dler.multitorrent.start_torrent(self.dler.metainfo,self.dler.torrentConfig, self.dler, self.dler.filename)

	finally:
	    self.dler.endRead()
            defaultDatabase.recomputeFilters()
	    
    def error(self, errormsg):
	print errormsg
            
    def display(self, statistics):
	update = False
	now = time()
	self.dler.beginRead()
	try:
	    if statistics.get('upTotal') != None:
		if self.lastUpTotal > statistics.get('upTotal'):
		    self.dler.uploaded += statistics.get('upTotal')
		else:
		    self.dler.uploaded += statistics.get('upTotal') - self.lastUpTotal
		self.lastUpTotal = statistics.get('upTotal')
	    if self.dler.state != "paused":
		self.dler.currentSize = int(self.dler.totalSize*statistics.get('fractionDone'))
	    if self.dler.state != "finished":
		self.dler.rate = statistics.get('downRate')
	    if self.dler.rate == None:
		self.dler.rate = 0.0
	    self.dler.eta = statistics.get('timeEst')
	    if self.dler.eta == None:
		self.dler.eta = 0
	    if self.lastUpdated < now-3:
		update = True
		self.lastUpdated = now
	finally:
	    self.dler.endRead()
	    if update:
		self.dler.item.beginChange()
		self.dler.item.endChange()

    ##
    # Called by pickle during serialization
    def __getstate__(self):
	temp = copy(self.__dict__)
	return temp

    ##
    # Called by pickle during deserialization
    def __setstate__(self,state):
	self.__dict__ = state

class BTDownloader(Downloader):
    def global_error(self, level, text):
        self.d.error(text)
    doneflag = threading.Event()
    torrentConfig = configfile.parse_configuration_and_args(defaults,'btdownloadheadless', [], 0, None)
    torrentConfig = torrentConfig[0]
    multitorrent = Multitorrent(torrentConfig, doneflag, global_error)

    def __init__(self, url, item):
	self.metainfo = None
        self.rate = 0
        self.eta = 0
        self.d = BTDisplay(self)
        self.uploaded = 0
        Downloader.__init__(self,url,item)

    def getRate(self):
        self.beginRead()
        ret = self.rate
        self.endRead()
        return ret

    def getETA(self):
        self.beginRead()
        ret = self.eta
        self.endRead()
        return ret
        
    def pause(self):
        self.beginRead()
        self.state = "paused"
        self.endRead()
	self.item.beginChange()
	self.item.endChange()
	try:
	    self.torrent.shutdown()
	except KeyError:
	    pass

    def stop(self):
        self.beginRead()
        self.state = "stopped"
        self.endRead()
	self.item.beginChange()
	self.item.endChange()
	self.torrent.shutdown()
	try:
	    self.torrent.shutdown()
	except KeyError:
	    pass
        try:
            remove(self.filename)
        except:
            pass

        pass

    def start(self):
        self.pause()
        self.beginRead()
	metainfo = self.metainfo
	if metainfo == None:
	    self.state = "failed"
	else:
	    self.state = "downloading"
        self.endRead()
	self.item.beginChange()
	self.item.endChange()
	if metainfo != None:
	    self.torrent = self.multitorrent.start_torrent(metainfo,
                                self.torrentConfig, self, self.filename)

    ##
    # Removes downloader from the database
    def remove(self):
        ScheduleEvent(0,self.pause,False)
        DDBObject.remove(self)

    def runDownloader(self,done=False):
	self.item.beginChange()
	self.item.endChange()
	if self.metainfo is None:
	    h = grabURL(self.getURL(),"GET")
            if h is None:
                self.beginChange()
                try:
                    self.state = "failed"
                finally:
                    self.endChange()
                return
            else:
                metainfo = h['file-handle'].read()
                h['file-handle'].close()
        try:
            # raises BTFailure if bad
	    if self.metainfo is None:
		metainfo = ConvertedMetainfo(bdecode(metainfo))
	    else:
		metainfo = self.metainfo
            self.shortFilename = metainfo.name_fs
	    if not done:
		self.filename = os.path.join(config.get('DataDirectory'),'Incomplete Downloads',self.shortFilename+".part")
		self.filename = self.nextFreeFilename(self.filename)
	    if self.metainfo is None:
		self.metainfo = metainfo
            self.set_torrent_values(self.metainfo.name, self.filename,
                                self.metainfo.total_bytes, len(self.metainfo.hashes))
            self.torrent = self.multitorrent.start_torrent(self.metainfo,
                                self.torrentConfig, self, self.filename)
        except BTFailure, e:
            print str(e)
            return
        self.get_status()

    ##
    # Functions below this point are needed by BitTorrent
    def set_torrent_values(self, name, path, size, numpieces):
        self.beginRead()
        try:
            self.totalSize = size
        finally:
            self.endRead()

    def exception(self, torrent, text):
        self.error(torrent, CRITICAL, text)

    def started(self, torrent):
        pass


    def get_status(self):
	#print str(self.getID()) + ": "+str(self.metainfo.infohash).encode('hex')
        self.multitorrent.rawserver.add_task(self.get_status,
                                             self.torrentConfig['display_interval'])
        status = self.torrent.get_status(False)
        self.d.display(status)

    def error(self, torrent, level, text):
        self.d.error(text)

    def failed(self, torrent, is_external):
        pass

    def finished(self, torrent):
        self.d.finished()

    def restartDL(self):
	if self.metainfo != None:
	    self.torrent = self.multitorrent.start_torrent(self.metainfo,
				      self.torrentConfig, self, self.filename)

	    self.get_status()
	else:
	    self.state = "paused"


    def __getstate__(self):
	temp = copy(self.__dict__)
	temp["thread"] = None
	try:
	    temp["torrent"] = None
	except:
	    pass
	return temp

    def __setstate__(self,state):
	self.__dict__ = state
        self.thread = Thread(target=self.restartDL)
        self.thread.setDaemon(True)
        self.thread.start()

##
# Kill the main BitTorrent thread
#
# This should be called before closing the app
def shutdownBTDownloader():
    BTDownloader.doneflag.set()
    BTDownloader.dlthread.join()

#Spawn the download thread
BTDownloader.dlthread = Thread(target=BTDownloader.multitorrent.rawserver.listen_forever)
BTDownloader.dlthread.start()

class DownloaderFactory:
    def __init__(self,item):
	self.item = item
    def getDownloader(self,url):
        info = grabURL(url,'GET')
        if info is None:
            return None
	if info['content-type'] == 'application/x-bittorrent':
            #print "Got BT Download"
            return BTDownloader(info['updated-url'],self.item)
	else:
            #print "Got HTTP download"
	    return HTTPDownloader(info['updated-url'],self.item)


if __name__ == "__main__":
    def printsaved():
	print "Saved!"
    def displayDLStatus(dler):
        print dler.getState()
        print str(dler.getCurrentSize()) + " of " + str(dler.getTotalSize())
        print str(dler.getETA()) + " seconds remaining"
        print str(dler.getRate()) + " bytes/sec"
        print "Saving to " + dler.getFilename()
    factory = DownloaderFactory(DDBObject())
    x = factory.getDownloader("http://www.blogtorrent.com/demo/btdownload.php?type=torrent&file=SatisfactionWeb.mov.torrent")
    y = factory.getDownloader("http://www.vimeo.com/clips/2005/04/05/vimeo.thelastminute.613.mov")
    ScheduleEvent(2,lambda :displayDLStatus(x),True)
    ScheduleEvent(2,lambda :displayDLStatus(y),True)
    sleep(60)
    x.stop()
