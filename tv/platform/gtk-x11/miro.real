#!/usr/bin/env python2.4
# -*- mode: python -*-

# This comes first.  Seriously.
from miro.plat import xlibhelper
if xlibhelper.XInitThreads() == 0:
    print "WARNING: XInitThreads() failed!"

import os.path
import sys
import optparse

import pygtk
pygtk.require('2.0')

from miro.plat import upgrade
upgrade.upgrade()

# Set up gettext before everything else
from miro import gtcache
gtcache.init()

from miro import config
from miro import plat
from miro.plat import options
from miro import prefs
from miro import singleclick

if '--unittest' in sys.argv:
    # handle this outside optparse, because unittest has its own option set
    sys.argv.remove('--unittest')
    import unittest
    from miro import test
    unittest.main(module=test)

def startup(props_to_set):
    if parsed_options.frontend == 'html':
        from miro.plat.frontends.html.Application import Application
        Application().run(props_to_set)
    elif parsed_options.frontend == 'cli':
        from miro.frontends import cli
        cli.run(parsed_options.theme)
    else:
        raise ValueError("Unknown frontend: %s" % parsed_options.frontend)

usage = "usage: %prog [options] [torrent files] [video files]"
parser = optparse.OptionParser(usage=usage)
parser.add_option('-v', '--version',
                  dest='version', action='store_true', 
                  help='print version info')
parser.set_defaults(version=False)

parser.add_option('--theme', 
                  dest='theme', metavar='<THEME>', 
                  help='Theme to use')
parser.add_option('--frontend', 
                  dest='frontend', metavar='<FRONTEND>',
                  help='Frontend to use (html, cli)')
parser.set_defaults(frontend="html")

group = optparse.OptionGroup(parser, "Settings options")
group.add_option('--list',
                 action="store_true",
                 dest="list_options",
                 help="Lists all preferences that can be set by command line.")
parser.set_defaults(list_options=False)
group.add_option('--set',
                 action="append",
                 dest="set_prefs",
                 metavar="<PREF>",
                 nargs=1,
                 help="Sets a preference and saves the new value for future Miro runs.  Example: miro --set renderer=xine")
parser.set_defaults(set_prefs=[])
parser.add_option_group(group)

group = optparse.OptionGroup(parser, "Debugging options")
group.add_option('--debug', 
                  action="store_true", 
                  help='Starts Miro in a gdb session for better debugging.')
group.add_option('--unittest', 
                  dest='unittest', action='store_true', 
                  help='Run unittests instead of launching the program.')
parser.set_defaults(unittest=False)
group.add_option('--profile', 
                  metavar='<FILE>', 
                  help='Write profiling information to FILE.')
group.add_option('--bias', 
                  metavar='<BIAS>', type=float,
                  help='Set profiling bias to BIAS.')
parser.set_defaults(bias=None)
group.add_option('--sync', 
                  action="store_true",
                  help='Use X syncronously.')
parser.set_defaults(sync=False)
parser.add_option_group(group)

(parsed_options, args) = parser.parse_args()

def get_keyval(keyval):
    key, val = keyval.split("=")
    if not key in options.PREFERENCES:
        print "Option '%s' does not exist." % (key)
        print "Exiting...."
        sys.exit(1)

    p = options.PREFERENCES[key]

    try:
        defaulttype = type(p.default)
        if defaulttype == unicode or defaulttype == str:
            pass
        elif defaulttype == float:
            val = float(val)
        elif defaulttype == int:
            val = int(val)
        elif defaulttype == bool:
            if val[0].lower() in ["t", "y", "1" ]:
                val = True
            else:
                val = False
    except Exception, e:
        print "Problem converting value to correct type: %s" % e
        print "Exiting...."
        sys.exit(1)

    return p, val

def startapp():
    plat.utils.initializeLocale()

    # Create miro directories in the user's home
    support_dir = config.get(prefs.SUPPORT_DIRECTORY)
    if not os.path.exists(support_dir):
        os.makedirs(support_dir)

    props_to_set = []

    for mem in parsed_options.set_prefs:
        p, val = get_keyval(mem)
        props_to_set.append( (p, val) )
   
    options.shouldSyncX = parsed_options.sync
    options.frontend = parsed_options.frontend
    if parsed_options.theme:
        options.themeName = parsed_options.theme
        print 'Theme is %s' % parsed_options.theme

    for i in xrange(len(args)):
        if args[i].startswith('file://'):
            args[i] = args[i][len('file://'):]

    singleclick.setCommandLineArgs(args)
    startup(props_to_set)

def print_version():
    print """
Miro (%s)

Miro comes with ABSOLUTELY NO WARRANTY.

This is free software, and you are welcome to redistribute it under certain 
conditions.  See license.txt for details.
""" % config.get(prefs.APP_VERSION)

if parsed_options.version:
    print_version()

elif parsed_options.list_options:
    print_version()

    print "Options that can be set:"
    for p in options.PREFERENCES.values():
        print "   %s\n      %s\n" % (p.alias, p.help)

elif parsed_options.profile:
    import profile
    import eventloop
    def main():
        startup()
    if (parsed_options.bias):
        profile.Profile.bias = parsed_options.bias
    eventloop.profile_file = parsed_options.profile
    profile.run ('main()', parsed_options.profile)

else:
    try:
        import dbus
        from miro.plat import onetime
        try:
            onetime.OneTime()
            startapp()
        except onetime.NameExistsException:
            # This onetime.NameExistsException is either dbus.NameExistsException 
            # or an exception we created ourselves.  Change it to 
            # dbus.NameExistsException when we get rid of code that allows Miro to
            # run on platforms with the older dbus-python bindings.
            bus = dbus.SessionBus()
            proxy_obj = bus.get_object('org.participatoryculture.dtv.onetime', '/org/participatoryculture/dtv/OneTime')
            iface = dbus.Interface(proxy_obj, 'org.participatoryculture.dtv.OneTimeIface')
            for i in xrange(len(args)):
                args[i] = args[i].decode('latin1')
            dbusargs = dbus.Array(args, signature="s")
    
            iface.HandleArgs(dbusargs)
        except dbus.DBusException:
            startapp()
    except ImportError:
        startapp()
